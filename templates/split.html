{% extends 'base.html' %}
{% block content %}
<section class="hero py-4 mb-3">
  <div class="container text-center">
    <h1 class="h3 fw-bold">Split PDF</h1>
    <p class="lead mb-3">Extract single pages or ranges into new files.</p>
  </div>
</section>

<section class="container mb-5">
  
    <div class="col-md-6-preview">
      <div class="card p-3 shadow-sm">
        <label class="form-label">Upload PDF</label>
  <input type="file" id="split_pdf_input" accept="application/pdf" class="form-control">
  <div id="split_file_hint" class="file-hint">No file selected</div>
        <div class="mt-3">
          <label class="form-label">Ranges (comma-separated, e.g. 1,3-5)</label>
          <input type="text" id="split_ranges" class="form-control" placeholder="e.g. 1,3-5">
        </div>
        <div class="mt-3">
          <button id="split_submit" class="btn btn-primary">Split</button>
        </div>
        <div id="split_progress_wrap" style="display:none" class="mt-3">
          <div class="merge-progress-bar"><div id="split_progress_fill" class="merge-progress-fill" style="width:0%"></div></div>
          <div class="small text-muted mt-1" id="split_progress_text">Preparing...</div>
        </div>
      </div>
    </div>

    <div class="col-md-6-preview">
      <div class="card p-3 shadow-sm">
        <h6>Preview & select pages</h6>
        <div class="d-flex justify-content-between align-items-center mb-2">
          <div>
            <button id="split_select_all" class="btn btn-sm btn-outline-primary">Select all</button>
            <button id="split_clear_all" class="btn btn-sm btn-outline-secondary">Clear</button>
          </div>
          <div id="split_preview_spinner" style="display:none"><span class="spinner spinner-sm"></span> Generating...</div>
        </div>
        <div id="split_preview_container" class="d-flex flex-wrap gap-5 mt-2"></div>
        <div class="mt-3">
          <small class="lead mb-0">Click thumbnails to toggle selection — selected pages will be used to build ranges automatically.</small>
        </div>
      </div>
    </div>
  
</section>

<script>
// Keep the thumbnail response cached so we can render selections on-demand
let __split_thumb_data = null
let __split_uploaded_file = null

document.getElementById('split_pdf_input').addEventListener('change', async e => {
  const f = e.target.files?.[0];
  const hint = document.getElementById('split_file_hint');
  hint.textContent = f ? `${f.name} • ${window.pdfpro.formatBytes(f.size)}` : 'No file selected';
  __split_thumb_data = null; __split_uploaded_file = f || null
  const container = document.getElementById('split_preview_container')
  if(window.pdfPreviews && typeof window.pdfPreviews.revokeBlobURLsInContainer === 'function'){
    try{ window.pdfPreviews.revokeBlobURLsInContainer(container) }catch(e){}
  }
  container.innerHTML = ''
  if(f){
    // upload to /thumbnails once and cache the server response
    const fd = new FormData(); fd.append('pdf', f)
    try{
      const spinner = document.getElementById('split_preview_spinner')
      spinner.style.display = 'inline-block'
      const res = await window.pdfpro.safeFetch('/thumbnails', { method:'POST', body: fd }, { errorMsg: 'Thumbnail generation failed' })
      const data = await res.json()
      __split_thumb_data = data
      // Render all thumbnails immediately so users can see pages right away
      try{
        const containerId = 'split_preview_container'
        const rangesInput = document.getElementById('split_ranges')
        // revoke any previous blobs/observers (defensive)
        const c = document.getElementById(containerId)
        try{ if(window.pdfPreviews && typeof window.pdfPreviews.revokeBlobURLsInContainer === 'function') window.pdfPreviews.revokeBlobURLsInContainer(c) }catch(e){}
        await window.pdfPreviews.generateForSplitFromData(__split_thumb_data, containerId, rangesInput)
      }catch(e){ console.error('render thumbs', e) }
      window.pdfpro.showMessage('Previews ready — type pages or click thumbnails to select', 'info')
      }catch(err){ console.error(err); window.pdfpro.showMessage('Failed to generate previews','error') }
    finally{ try{ document.getElementById('split_preview_spinner').style.display='none' }catch(e){} }
  }
});

document.getElementById('split_submit').addEventListener('click', async () => {
  const f = document.getElementById('split_pdf_input').files?.[0];
  let ranges = document.getElementById('split_ranges').value || '';
  if(!f){ window.pdfpro.showMessage('Select a PDF', 'error'); return; }
  const fd = new FormData(); fd.append('pdf', f); fd.append('ranges', ranges);
  const btn = document.getElementById('split_submit');
  try{
    // if no explicit ranges, rely on selected pages in the preview (ranges input is updated automatically)
    if(!ranges && __split_thumb_data){ ranges = document.getElementById('split_ranges').value || '' }
    fd.set('ranges', ranges)
    // show progress UI
    const wrap = document.getElementById('split_progress_wrap'); const fill = document.getElementById('split_progress_fill'); const text = document.getElementById('split_progress_text');
    wrap.style.display='block'; fill.style.width='0%'; text.textContent='Uploading...'
    const res = await uploadWithProgress('/split', fd, (loaded,total)=>{ if(total){ const pct=Math.round((loaded/total)*100); fill.style.width=pct+'%'; text.textContent=`Uploading... ${pct}%`} else { fill.style.width='40%'; text.textContent='Uploading...' } })
    fill.style.width='100%'; text.textContent='Processing...'
    const blob = await res.blob(); const url = URL.createObjectURL(blob);
    // prefer server-provided filename header
    let fname = 'split_files.pdf'
    try{ const cd = res.headers.get('Content-Disposition') || ''; const xdn = res.headers.get('X-Download-Name'); if(xdn) fname = xdn; else if(cd){ const m = cd.match(/filename="?([^";]+)"?/); if(m) fname = m[1] } }catch(e){}
    const a = document.createElement('a'); a.href = url; a.download = fname; document.body.appendChild(a); a.click(); a.remove();
  }catch(err){ console.error(err); window.pdfpro.showMessage('Split failed','error') }
  finally{ setTimeout(()=>{ try{ document.getElementById('split_progress_wrap').style.display='none'; document.getElementById('split_progress_fill').style.width='0%'}catch(e){} },800) }
});

// When user types ranges, render previews and auto-select pages matching the ranges
document.getElementById('split_ranges').addEventListener('input', e => {
  const val = e.target.value || ''
  const containerId = 'split_preview_container'
  if(__split_thumb_data){
    // pass the input element wrapper to let preview updateRanges update it
    const inputWrapper = e.target
    // mark wrapper so previews helper can detect it
    inputWrapper._isInput = true
    // revoke any existing blob URLs first
    const c = document.getElementById(containerId)
    try{ window.pdfPreviews.revokeBlobURLsInContainer(c) }catch(e){}
    window.pdfPreviews.generateForSplitFromDataSelected(__split_thumb_data, containerId, inputWrapper)
  }
})

// wire up toolbar buttons
document.getElementById('split_select_all').addEventListener('click', ()=>{
  const containerId = 'split_preview_container'
  const rangesInput = document.getElementById('split_ranges')
  window.pdfPreviews.selectAllThumbnails(containerId, rangesInput)
})
document.getElementById('split_clear_all').addEventListener('click', ()=>{
  const containerId = 'split_preview_container'
  const rangesInput = document.getElementById('split_ranges')
  window.pdfPreviews.clearSelectionThumbnails(containerId, rangesInput)
})

// helper to upload FormData with progress callback (shared pattern)
function uploadWithProgress(url, formData, onProgress){
  return new Promise((resolve,reject)=>{
    const xhr = new XMLHttpRequest(); xhr.open('POST', url, true); xhr.responseType = 'blob';
    xhr.upload.onprogress = function(e){ if(onProgress) onProgress(e.loaded, e.total) }
    xhr.onload = function(){
      if(xhr.status>=200 && xhr.status<300){
        const headers = new Headers();
        try{ xhr.getAllResponseHeaders().trim().split(/\r?\n/).forEach(line=>{ const idx=line.indexOf(':'); if(idx>0) headers.append(line.slice(0,idx).trim(), line.slice(idx+1).trim()) }) }catch(e){}
        const res = new Response(xhr.response, { status: xhr.status, statusText: xhr.statusText, headers })
        resolve(res)
      } else reject(new Error('Upload failed: '+xhr.status))
    }
    xhr.onerror = function(){ reject(new Error('Network error')) }
    xhr.send(formData)
  })
}
</script>
{% endblock %}