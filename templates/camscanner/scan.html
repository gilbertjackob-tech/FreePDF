{% extends 'base.html' %}
{% block content %}
<section class="hero py-4 mb-3">
  <div class="container text-center">
    <h1 class="h3 fw-bold">Scanner</h1>
    <p class="lead mb-3">Capture document pages with camera or upload images. Tap the shutter to add to your scan session.</p>
  </div>
</section>

<section class="container mb-5">
  <div class="row">
    <div class="col-lg-8">
      <div class="card shadow-sm p-0">
      <div class="position-relative camera-holder"> 
        <video id="scanner_video" autoplay playsinline muted class="w-100 h-100 camera-video" style="object-fit:cover;"></video>
            <canvas id="scanner_canvas" class="d-none"></canvas>
            <div id="scanner_overlay" class="position-absolute top-0 start-0 w-100 h-100 d-flex align-items-end justify-content-center p-3 pointer-events-none">
              <div class="bg-black bg-opacity-50 text-white rounded px-3 py-2 pointer-events-auto" id="scanner_status">Ready</div>
            </div>
            <!-- Floating camera toolbar -->
            <div class="camera-toolbar" role="toolbar" aria-label="Camera controls">
              <button id="shutter_btn" class="btn btn-primary btn-icon" title="Capture"><i class="bi bi-camera-fill"></i></button>
              <button id="flip_btn" class="btn btn-outline-secondary btn-icon" title="Flip"><i class="bi bi-arrow-repeat"></i></button>
              <button id="camera_toggle_btn" class="btn btn-outline-secondary btn-icon" title="Camera On/Off"><i class="bi bi-camera-video-off-fill"></i></button>
              <button id="upload_btn" class="btn btn-warning btn-icon" title="Upload"><i class="bi bi-upload"></i></button>
              <button id="done_btn" class="btn btn-success btn-icon" title="Finish"><i class="bi bi-check2-circle"></i></button>
            </div>
          </div>
          <div class="card-body d-flex gap-2 align-items-center justify-content-center flex-wrap">
            <div class="d-flex align-items-center ms-2">
              <div class="form-check form-switch">
                <input class="form-check-input" type="checkbox" id="orientation_toggle">
                <label class="form-check-label ms-2" for="orientation_toggle">Landscape</label>
              </div>
            </div>
            <!-- file input fallback for mobile devices (capture attribute requests camera on compatible phones) -->
            <input type="file" id="file_input" accept="image/*" capture="environment" style="display:none" multiple>
            <div id="mobile_fallback_msg" class="text-center text-muted small mt-2" style="display:none">
              Camera not available. Use the Upload button to pick images or open this page in Safari (iOS) with HTTPS.
            </div>
            <div class="input-group ms-2" style="width:160px;">
              <span class="input-group-text">Margin</span>
              <input id="margin_px" type="number" class="form-control" value="10" min="0" step="1">
              <div class="input-group-text">px</div>
            </div>
          </div>
      </div>
    </div>

    <div class="col-lg-4">
      <div class="card shadow-sm p-3">
  <h6>Captured Pages</h6>
  <div id="scan_gallery" class="d-flex flex-column gap-2" style="max-height:60vh; overflow:auto;"></div>
        <div class="mt-3 d-flex gap-2 flex-wrap">
          <button id="clear_session" class="btn btn-sm btn-outline-danger">Clear</button>
        </div>
        <div id="scan_progress_wrap" style="display:none; margin-top:5px;">
          <div id="scan_progress_fill" style="width:0%; height:10px; background:#28a745;"></div>
          <div id="scan_progress_text" style="font-size:0.9em; margin-top:2px;">Uploading...</div>
        </div>
      </div>
    </div>
  </div>
</section>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>

<script>
(async function(){
  const video = document.getElementById('scanner_video');
  const canvas = document.getElementById('scanner_canvas');
  const shutterBtn = document.getElementById('shutter_btn');
  const flipBtn = document.getElementById('flip_btn');
  const uploadBtn = document.getElementById('upload_btn');
  const fileInput = document.getElementById('file_input');
  const doneBtn = document.getElementById('done_btn');
  const galleryDiv = document.getElementById('scan_gallery');
  const marginKeep = document.getElementById('margin_keep');
  const marginPxInput = document.getElementById('margin_px');
  const statusDiv = document.getElementById('scanner_status');
  const wrap = document.getElementById('scan_progress_wrap');
  const fill = document.getElementById('scan_progress_fill');
  const text = document.getElementById('scan_progress_text');

  let stream = null;
  let usingFrontCamera = false;
  let cameraOn = true;
  let capturedPages = [];
  // each capturedPages[i] will be a Blob/File

  async function startCamera() {
    if(stream){ stream.getTracks().forEach(t=>t.stop()); }
    cameraOn = true; updateCameraToggleUI();
    // Try with facingMode hint first (better for rear/front selection). If that fails (some iOS/Safari), try a simpler constraint.
    try {
      stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: usingFrontCamera?"user":"environment" } });
      video.srcObject = stream;
      statusDiv.innerText = "Ready";
      document.getElementById('mobile_fallback_msg').style.display = 'none';
      return;
    } catch(e){
      console.warn("Primary camera request failed, retrying with simpler constraints", e);
    }

    // Second attempt without facingMode (some browsers reject facingMode on insecure contexts or older engines)
    try {
      stream = await navigator.mediaDevices.getUserMedia({ video: true });
      video.srcObject = stream;
      statusDiv.innerText = "Ready";
      document.getElementById('mobile_fallback_msg').style.display = 'none';
      return;
    } catch(e){
      console.warn("Fallback camera request failed", e);
      // Provide a helpful hint for iOS users
      if(/Safari/.test(navigator.userAgent) && !window.isSecureContext){
        statusDiv.innerText = "Camera requires secure context (HTTPS) - open in Safari via HTTPS";
      } else {
        statusDiv.innerText = "Camera not available. Use upload.";
      }
      document.getElementById('mobile_fallback_msg').style.display = 'block';
    }
  }

  flipBtn.addEventListener('click', ()=>{ usingFrontCamera = !usingFrontCamera; startCamera(); });

  // orientation toggle: switch video container aspect ratio between portrait A4 and landscape A4
  const orientationToggle = document.getElementById('orientation_toggle');
  const videoContainer = document.querySelector('.card .position-relative');
  function applyOrientation(){
    if(orientationToggle && videoContainer){
      if(orientationToggle.checked){
        videoContainer.style.aspectRatio = '297/210'; // landscape
      } else {
        videoContainer.style.aspectRatio = '210/297'; // portrait
      }
    }
  }
  if(orientationToggle){ orientationToggle.addEventListener('change', applyOrientation); applyOrientation(); }

  // Camera toggle on/off
  const cameraToggleBtn = document.getElementById('camera_toggle_btn');
  function stopCamera(){ if(stream){ stream.getTracks().forEach(t=>t.stop()); stream = null; } cameraOn = false; video.srcObject = null; statusDiv.innerText = 'Camera off'; updateCameraToggleUI(); }
  function updateCameraToggleUI(){
    if(cameraOn){
      cameraToggleBtn.innerHTML = '<i class="bi bi-camera-video-fill"></i>';
      cameraToggleBtn.classList.remove('btn-success');
      cameraToggleBtn.classList.add('btn-outline-secondary');
      cameraToggleBtn.title = 'Turn Camera Off';
    } else {
      cameraToggleBtn.innerHTML = '<i class="bi bi-camera-video-off-fill"></i>';
      cameraToggleBtn.classList.remove('btn-outline-secondary');
      cameraToggleBtn.classList.add('btn-success');
      cameraToggleBtn.title = 'Turn Camera On';
    }
  }
  cameraToggleBtn.addEventListener('click', ()=>{ if(cameraOn) stopCamera(); else startCamera(); });

  uploadBtn.addEventListener('click', ()=>fileInput.click());
  // per-image edit history for undo/redo
  const capturedHistories = [];
  const historyIndex = [];

  // add gallery item helper (with crop/rotate/remove and drag)
  function createGalleryItem(blob, idx){
    const url = URL.createObjectURL(blob);
    const wrap = document.createElement('div'); wrap.className='d-flex align-items-center gap-2 p-2 border rounded';
    wrap.draggable = true; wrap.dataset.index = idx;
    const img = document.createElement('img'); img.src=url; img.className='img-fluid'; img.style.maxWidth='160px'; img.style.maxHeight='120px';
  const controls = document.createElement('div'); controls.className='d-flex flex-column gap-2';
  const up = document.createElement('button'); up.className='btn btn-sm btn-outline-secondary'; up.innerHTML='<i class="bi bi-crop"></i>'; up.title='Crop/Rotate';
  const undoBtn = document.createElement('button'); undoBtn.className='btn btn-sm btn-outline-secondary'; undoBtn.innerHTML='<i class="bi bi-arrow-counterclockwise"></i>'; undoBtn.title='Undo';
  const redoBtn = document.createElement('button'); redoBtn.className='btn btn-sm btn-outline-secondary'; redoBtn.innerHTML='<i class="bi bi-arrow-clockwise"></i>'; redoBtn.title='Redo';
  const remove = document.createElement('button'); remove.className='btn btn-sm btn-outline-danger'; remove.innerHTML='<i class="bi bi-trash"></i>'; remove.title='Delete';
    controls.appendChild(up); controls.appendChild(undoBtn); controls.appendChild(redoBtn); controls.appendChild(remove);
    wrap.appendChild(img); wrap.appendChild(controls);

    // drag handlers
    wrap.addEventListener('dragstart', (ev)=>{ ev.dataTransfer.setData('text/plain', ev.currentTarget.dataset.index); ev.currentTarget.classList.add('opacity-50'); });
    wrap.addEventListener('dragend', (ev)=>{ ev.currentTarget.classList.remove('opacity-50'); });
    wrap.addEventListener('dragover', ev=>{ ev.preventDefault(); ev.currentTarget.style.outline='2px dashed #007bff'; });
    wrap.addEventListener('dragleave', ev=>{ ev.currentTarget.style.outline=''; });
    wrap.addEventListener('drop', ev=>{
      ev.preventDefault(); ev.currentTarget.style.outline='';
      const from = parseInt(ev.dataTransfer.getData('text/plain'),10);
      const to = parseInt(ev.currentTarget.dataset.index,10);
      if(isNaN(from) || isNaN(to) || from===to) return;
      // reorder capturedPages
      const item = capturedPages.splice(from,1)[0];
      capturedPages.splice(to,0,item);
      renderGallery();
    });

    // remove
    remove.addEventListener('click', ()=>{
      const i = parseInt(wrap.dataset.index,10); capturedPages.splice(i,1); renderGallery();
    });

    // undo/redo
    undoBtn.addEventListener('click', ()=>{
      const i = parseInt(wrap.dataset.index,10);
      if(!capturedHistories[i] || historyIndex[i] <= 0) return;
      historyIndex[i]--; capturedPages[i] = capturedHistories[i][historyIndex[i]]; renderGallery();
    });
    redoBtn.addEventListener('click', ()=>{
      const i = parseInt(wrap.dataset.index,10);
      if(!capturedHistories[i] || historyIndex[i] >= capturedHistories[i].length-1) return;
      historyIndex[i]++; capturedPages[i] = capturedHistories[i][historyIndex[i]]; renderGallery();
    });

    // crop/rotate
    up.addEventListener('click', ()=>{
      openCropperWithCropperJS(blob, async (newBlob)=>{
        if(newBlob){
          const i = parseInt(wrap.dataset.index,10);
          if(!capturedHistories[i]){ capturedHistories[i] = [capturedPages[i]]; historyIndex[i]=0; }
          // drop forward history
          capturedHistories[i] = capturedHistories[i].slice(0, historyIndex[i]+1);
          capturedHistories[i].push(newBlob); historyIndex[i] = capturedHistories[i].length-1;
          capturedPages[i] = newBlob; renderGallery();
        }
      });
    });

    return wrap;
  }

  fileInput.addEventListener('change', e=>{
    for(const f of e.target.files){
      capturedPages.push(f);
    }
    e.target.value=''; renderGallery();
  });

  function renderGallery(){
    galleryDiv.innerHTML='';
    capturedPages.forEach((b,i)=>{
      const node = createGalleryItem(b,i); node.dataset.index = i; galleryDiv.appendChild(node);
    });
  }

  async function capturePage(){
    canvas.width = video.videoWidth; canvas.height = video.videoHeight;
    canvas.getContext('2d').drawImage(video,0,0);
    return new Promise(resolve=>canvas.toBlob(resolve,'image/jpeg',0.9));
  }

  shutterBtn.addEventListener('click', async ()=>{
    if(!stream){ alert("Camera not available. Use Upload."); return; }
    statusDiv.innerText="Processing...";
    try {
      const blob = await capturePage();
      const fd = new FormData();
      fd.append('file', blob, 'page.jpg');
      const res = await fetch('/scan-perspective', { method:'POST', body: fd });
      if(!res.ok){ statusDiv.innerText="Error"; return; }
  const processedBlob = await res.blob();
  capturedPages.push(processedBlob);
  renderGallery();
      statusDiv.innerText="Ready";
    } catch(e){ console.error(e); statusDiv.innerText="Error"; }
  });

  doneBtn.addEventListener('click', async ()=>{
    if(!capturedPages.length){ alert("No pages captured"); return; }
    const fd = new FormData();
    // apply margin client-side if requested
    const keepMargin = marginKeep && marginKeep.checked;
    const marginPx = parseInt(marginPxInput.value,10) || 0;
    for(let i=0;i<capturedPages.length;i++){
      const b = capturedPages[i];
      if(keepMargin && marginPx>0){
        // add margin by drawing to canvas
        const newBlob = await addMarginToBlob(b, marginPx);
        fd.append('file', newBlob, `page${i+1}.jpg`);
      } else {
        fd.append('file', b, `page${i+1}.jpg`);
      }
    }
    wrap.style.display='block'; fill.style.width='0%'; text.textContent='Uploading...';
    try {
      const res = await uploadWithProgress('/merge-pdf', fd, (loaded,total)=>{
        const pct = total ? Math.round((loaded/total)*100) : 40;
        fill.style.width=pct+'%'; text.textContent='Uploading... '+pct+'%';
      });
      fill.style.width='100%'; text.textContent='Processing...';
  const blob = await res.blob();
  const url = URL.createObjectURL(blob);
  // force download
  const a = document.createElement('a'); a.href = url; a.download = 'scanned_pages.pdf'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    } catch(e){ console.error(e); text.textContent='Error'; }
    finally{ setTimeout(()=>{ wrap.style.display='none'; fill.style.width='0%'; },800); }
  });

  document.getElementById('clear_session').addEventListener('click', ()=>{
    capturedPages=[]; galleryDiv.innerHTML=''; statusDiv.innerText="Ready";
  });

  if(navigator.mediaDevices && navigator.mediaDevices.getUserMedia){ startCamera(); } 
  else { statusDiv.innerText="Camera unsupported. Use upload."; }

  function uploadWithProgress(url, formData, onProgress){
    return new Promise((resolve,reject)=>{
      const xhr = new XMLHttpRequest();
      xhr.open('POST', url, true);
      xhr.responseType='blob';
      xhr.upload.onprogress = e=>{ if(onProgress) onProgress(e.loaded,e.total); };
      xhr.onload = ()=>{ 
        if(xhr.status>=200 && xhr.status<300){ 
          resolve(new Response(xhr.response, { status:xhr.status, statusText:xhr.statusText })); 
        } else reject(new Error('Upload failed: '+xhr.status)); 
      };
      xhr.onerror = ()=>reject(new Error('Network error'));
      xhr.send(formData);
    });
  }

  // addMarginToBlob: draw image onto larger canvas with margin (px)
  function addMarginToBlob(blob, margin){
    return new Promise((resolve,reject)=>{
      const img = new Image(); img.onload = ()=>{
        const w = img.naturalWidth, h = img.naturalHeight;
        const c = document.createElement('canvas'); c.width = w + margin*2; c.height = h + margin*2;
        const ctx = c.getContext('2d'); ctx.fillStyle='white'; ctx.fillRect(0,0,c.width,c.height); ctx.drawImage(img, margin, margin);
        c.toBlob(b=>resolve(b),'image/jpeg',0.9);
      }; img.onerror = reject; img.src = URL.createObjectURL(blob);
    });
  }

  // crop/rotate modal using Cropper.js
  function openCropperWithCropperJS(blob, cb){
    let modal = document.getElementById('scan_cropper_modal');
    if(!modal){
      modal = document.createElement('div'); modal.id='scan_cropper_modal'; modal.className='position-fixed top-0 start-0 w-100 h-100 d-none'; modal.style.background='rgba(0,0,0,0.7)'; modal.style.zIndex=2000; modal.style.display='flex'; modal.style.alignItems='center'; modal.style.justifyContent='center';
      modal.innerHTML = `
        <div style="background:#fff;padding:12px;max-width:95%;max-height:90%;overflow:auto;">
          <h6>Crop & Rotate</h6>
          <div style="position:relative;max-width:800px;">
            <img id="scan_cropper_img" style="max-width:100%;display:block;" />
            <div class="mt-2 d-flex gap-2 justify-content-end align-items-center">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="crop_aspect_lock">
                <label class="form-check-label ms-2" for="crop_aspect_lock">Lock A4 aspect</label>
              </div>
              <button id="scan_cropper_rot_left" class="btn btn-sm btn-outline-secondary">⟲</button>
              <button id="scan_cropper_rot_right" class="btn btn-sm btn-outline-secondary">⟳</button>
              <button id="scan_cropper_cancel" class="btn btn-sm btn-outline-secondary">Cancel</button>
              <button id="scan_cropper_ok" class="btn btn-sm btn-primary">Apply</button>
            </div>
          </div>
        </div>`;
      document.body.appendChild(modal);
    }
    const imgEl = modal.querySelector('#scan_cropper_img');
    const aspectLock = modal.querySelector('#crop_aspect_lock');
    let cropper = null;
    imgEl.src = URL.createObjectURL(blob);
    modal.classList.remove('d-none');
    imgEl.onload = ()=>{
      if(cropper) cropper.destroy();
      cropper = new Cropper(imgEl, { viewMode:1, autoCropArea:0.9, movable:true, zoomable:true, rotatable:true, responsive:true, background:false });
      aspectLock.addEventListener('change', ()=>{
        if(aspectLock.checked) cropper.setAspectRatio(8.27/11.69); else cropper.setAspectRatio(NaN);
      });
    };
    modal.querySelector('#scan_cropper_rot_left').onclick = ()=>{ if(cropper) cropper.rotate(-90); };
    modal.querySelector('#scan_cropper_rot_right').onclick = ()=>{ if(cropper) cropper.rotate(90); };
    modal.querySelector('#scan_cropper_cancel').onclick = ()=>{ if(cropper) cropper.destroy(); modal.classList.add('d-none'); cb(null); };
    modal.querySelector('#scan_cropper_ok').onclick = ()=>{
      if(!cropper){ cb(null); return; }
      cropper.getCroppedCanvas().toBlob(b=>{ cropper.destroy(); modal.classList.add('d-none'); cb(b); }, 'image/jpeg', 0.9);
    };
  }
})();
</script>
{% endblock %}
