{% extends 'base.html' %}
{% block content %}
<section class="hero py-4 mb-3">
  <div class="container text-center">
    <h1 class="h3 fw-bold">Edit PDF</h1>
    <p class="lead mb-3">Rotate, remove or reorder pages and produce an edited PDF.</p>
  </div>
</section>

<section class="container mb-5">
  <div class="row">
    <div class="col-md-6-preview">
      <div class="card shadow-sm rounded-3 p-3 mb-3">
        <label class="form-label">Upload PDF for editing</label>
        <input type="file" id="upload_pdf" class="form-control" accept="application/pdf" aria-label="Upload PDF">
        <div class="mt-3">
          <label class="form-label">Rotate (degrees)</label>
          <input type="number" id="rotate" class="form-control" value="0" aria-label="Rotate degrees">
        </div>
        <div class="mt-3 d-flex align-items-center gap-2">
          <button id="generate_thumbs" class="btn btn-outline-primary">Generate thumbnails <span id="generate_progress" class="small text-muted ms-2" aria-live="polite"></span></button>
          <button id="undo_delete" class="btn btn-sm btn-outline-secondary" disabled>Undo last delete</button>
          <button id="clear_thumbs" class="btn btn-sm btn-outline-danger">Clear</button>
          <div class="lead mb-0">Selected for deletion: <span id="delete_count">0</span></div>
        </div>
        <div class="mt-3">
          <button id="apply_edit" class="btn btn-primary">Apply</button>
        </div>
        <div id="edit_progress_wrap" style="display:none" class="mt-3">
          <div class="merge-progress-bar"><div id="edit_progress_fill" class="merge-progress-fill" style="width:0%"></div></div>
          <div class="small text-muted mt-1" id="edit_progress_text">Preparing...</div>
        </div>
      </div>
    </div>

    <div class="col-md-6-preview">
      <label class="form-label">Pages & thumbnails</label>
      <div id="thumb_container" class="d-flex flex-wrap gap-2" style="min-height:200px; border:1px dashed var(--muted); padding:8px;">
        <!-- thumbnails inserted here -->
      </div>
    </div>
  </div>
</section>

<script>
let currentFileId = null;
let lastDeletedStack = [];

async function generateThumbs(){
  const input = document.getElementById('upload_pdf');
  const file = input.files?.[0];
  const fd = new FormData();
  if(file) fd.append('pdf', file);
  else if(currentFileId) fd.append('file_id', currentFileId);
  else { alert('Select a file or use an existing file id'); return; }

  const prog = document.getElementById('generate_progress');
  prog.textContent = 'working...';
  prog.classList.add('progress-visible');
  try{
    const token = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
    const headers = token ? { 'X-CSRFToken': token } : {};
    const res = await fetch('/thumbnails', { method: 'POST', headers, body: fd });
    if(!res.ok){ const err = await res.json().catch(()=>({})); alert('thumbnail generation failed: '+(err.error||res.status)); prog.textContent=''; prog.classList.remove('progress-visible'); return; }
    const data = await res.json();
    currentFileId = data.file_id;
    // revoke any prior blob URLs before inserting new thumbs
    revokeBlobURLsInContainer();
    renderThumbs(data.thumbs || []);
  }catch(e){ console.error(e); alert('Network error'); }
  prog.textContent = '';
  prog.classList.remove('progress-visible');
}

function revokeBlobURLsInContainer(){
  try{
    const container = document.getElementById('thumb_container');
    if(!container) return;
    const imgs = container.querySelectorAll('img');
    imgs.forEach(img => { try{ const s = img.src || ''; if(s.startsWith('blob:')) URL.revokeObjectURL(s); }catch(e){} });
  }catch(e){ console.warn('revoke error', e); }
}

function renderThumbs(thumbs){
  const container = document.getElementById('thumb_container');
  // revoke any blob urls we previously created before wiping DOM
  revokeBlobURLsInContainer();
  container.innerHTML = '';
  thumbs.forEach((url, idx) => {
    const card = document.createElement('div');
    card.className = 'thumb-item thumb-card grab-cursor';
    card.draggable = true;
    card.dataset.page = idx+1;
    card.innerHTML = `
      <div class="position-relative">
        <div class="select-badge" aria-hidden="true">✓</div>
        <img src="${url}" class="id-preview-img" alt="Page ${idx+1} thumbnail"/>
        <div class="overlay position-absolute top-0 start-0 w-100 h-100"></div>
      </div>
      <div class="text-center small">Page ${idx+1}</div>
    `;
    container.appendChild(card);
  });
  enableDragDrop(); enableDeleteToggle(); enableMultiSelect(); updateDeleteCounter();
}

function enableDragDrop(){
  const container = document.getElementById('thumb_container');
  let dragged = null;
  container.querySelectorAll('.thumb-item').forEach(item => {
    item.addEventListener('dragstart', e => { dragged = item; item.classList.add('dragging'); });
    item.addEventListener('dragend', e => { dragged = null; item.classList.remove('dragging'); });
    item.addEventListener('dragover', e => e.preventDefault());
    item.addEventListener('drop', e => {
      e.preventDefault(); if(!dragged || dragged === item) return;
      const all = Array.from(container.children); const from = all.indexOf(dragged); const to = all.indexOf(item);
      if(from<0||to<0) return; if(from<to) container.insertBefore(dragged, item.nextSibling); else container.insertBefore(dragged, item);
    });
  });
}

function enableDeleteToggle(){
  const container = document.getElementById('thumb_container');
  container.querySelectorAll('.thumb-item').forEach(item => item.addEventListener('click', e => { if(e.shiftKey) return; toggleDelete(item); }));
}

function toggleDelete(item){
  const overlay = item.querySelector('.overlay'); if(!overlay) return;
  if(overlay.classList.contains('overlay-show')){ overlay.classList.remove('overlay-show'); delete item.dataset.delete; item.classList.remove('selected'); }
  else { overlay.classList.add('overlay-show'); item.dataset.delete='1'; item.classList.add('selected'); lastDeletedStack.push(item.dataset.page); }
  updateDeleteCounter(); updateUndoState();
}

function updateDeleteCounter(){ document.getElementById('delete_count').innerText = document.querySelectorAll('#thumb_container .thumb-item[data-delete]').length; }

function updateUndoState(){ const undo = document.getElementById('undo_delete'); undo.disabled = !(lastDeletedStack && lastDeletedStack.length>0); }

function enableMultiSelect(){
  const container = document.getElementById('thumb_container'); const items = Array.from(container.querySelectorAll('.thumb-item'));
  let last = null; items.forEach((item,idx)=> item.addEventListener('click', e=>{ if(!e.shiftKey){ last=idx; return } const start=Math.min(last??idx,idx), end=Math.max(last??idx,idx); for(let i=start;i<=end;i++) toggleDelete(items[i]); }));
}

document.getElementById('undo_delete').addEventListener('click', e=>{ e.preventDefault(); const id = lastDeletedStack.pop(); if(!id){ updateUndoState(); return; } const item = document.querySelector(`#thumb_container .thumb-item[data-page='${id}']`); if(item){ const overlay=item.querySelector('.overlay'); overlay && overlay.classList.remove('overlay-show'); delete item.dataset.delete; item.classList.remove('selected'); } updateDeleteCounter(); updateUndoState(); });

document.getElementById('clear_thumbs').addEventListener('click', e=>{ e.preventDefault(); if(!confirm('Clear thumbnails and reset current file?')) return; revokeBlobURLsInContainer(); document.getElementById('thumb_container').innerHTML=''; currentFileId = null; lastDeletedStack = []; updateDeleteCounter(); updateUndoState(); document.getElementById('generate_progress').textContent=''; });

async function applyEdit(){
  const container = document.getElementById('thumb_container'); const items = Array.from(container.children);
  if(items.length===0){ alert('No pages to submit'); return; }
  const order = items.map(it=>it.dataset.page).join(','); const rotate = document.getElementById('rotate').value || '0';
  const deleteList = items.filter(it=>it.dataset.delete).map(it=>it.dataset.page).join(',');
  if(!currentFileId){ alert('No uploaded file id — please generate thumbnails first'); return; }
  const fd = new FormData(); fd.append('file_id', currentFileId); fd.append('pages', order); fd.append('rotate', rotate); fd.append('delete', deleteList);
  const csrf = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content'); const headers = csrf ? { 'X-CSRFToken': csrf } : {};
  const res = await fetch('/edit', { method:'POST', headers, body: fd });
  if(!res.ok){ alert('Edit failed'); return; }
  const blob = await res.blob(); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='edited.pdf'; document.body.appendChild(a); a.click(); a.remove();
}

document.getElementById('generate_thumbs').addEventListener('click', e=>{ e.preventDefault(); generateThumbs().catch(err=>{ console.error(err); alert('Error'); }); });
async function applyEdit(){
  const container = document.getElementById('thumb_container'); const items = Array.from(container.children);
  if(items.length===0){ alert('No pages to submit'); return; }
  const order = items.map(it=>it.dataset.page).join(','); const rotate = document.getElementById('rotate').value || '0';
  const deleteList = items.filter(it=>it.dataset.delete).map(it=>it.dataset.page).join(',');
  if(!currentFileId){ alert('No uploaded file id — please generate thumbnails first'); return; }
  const fd = new FormData(); fd.append('file_id', currentFileId); fd.append('pages', order); fd.append('rotate', rotate); fd.append('delete', deleteList);
  const csrf = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content'); const headers = csrf ? { 'X-CSRFToken': csrf } : {};
  // show progress UI
  const wrap = document.getElementById('edit_progress_wrap'); const fill = document.getElementById('edit_progress_fill'); const text = document.getElementById('edit_progress_text');
  wrap.style.display='block'; fill.style.width='0%'; text.textContent='Uploading...'
  try{
    const res = await uploadWithProgress('/edit', fd, (loaded,total)=>{ if(total){ const pct=Math.round((loaded/total)*100); fill.style.width=pct+'%'; text.textContent=`Uploading... ${pct}%`} else { fill.style.width='40%'; text.textContent='Uploading...' } })
    fill.style.width='100%'; text.textContent='Processing...'
    if(!res.ok){ alert('Edit failed'); return }
    const blob = await res.blob(); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='edited.pdf'; document.body.appendChild(a); a.click(); a.remove();
  }catch(e){ console.error(e); alert('Edit failed') }
  finally{ setTimeout(()=>{ try{ wrap.style.display='none'; fill.style.width='0%'}catch(e){} },800) }
}

document.getElementById('apply_edit').addEventListener('click', e=>{ e.preventDefault(); applyEdit().catch(err=>{ console.error(err); alert('Error'); }); });

function uploadWithProgress(url, formData, onProgress){
  return new Promise((resolve,reject)=>{
    const xhr = new XMLHttpRequest(); xhr.open('POST', url, true); xhr.responseType = 'blob';
    xhr.upload.onprogress = function(e){ if(onProgress) onProgress(e.loaded, e.total) }
    xhr.onload = function(){ if(xhr.status>=200 && xhr.status<300){ const headers = new Headers(); try{ xhr.getAllResponseHeaders().trim().split(/\r?\n/).forEach(line=>{ const idx=line.indexOf(':'); if(idx>0) headers.append(line.slice(0,idx).trim(), line.slice(idx+1).trim()) }) }catch(e){} const res = new Response(xhr.response, { status: xhr.status, statusText: xhr.statusText, headers }); resolve(res) } else reject(new Error('Upload failed: '+xhr.status)) }
    xhr.onerror = function(){ reject(new Error('Network error')) }
    xhr.send(formData)
  })
}
</script>
{% endblock %}